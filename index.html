<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>JavaScript Fundamentals ‚Äì Course Notes</title>
  <style>
    :root {
      --bg: #0b1020;
      --panel: #0f1630;
      --ink: #e7ecff;
      --muted: #b8c0e0;
      --accent: #7aa2ff;
      --accent-2: #33d6a6;
      --border: #26304d;
      --code: #0b1226;
      --surface: #202a4c;

    }

    html,
    body {
      margin: 0;
      font: 16px/1.6 system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial;
      color: var(--ink);
      background: var(--bg);
      scroll-behavior: smooth;
    }

    a {
      color: var(--accent);
      text-decoration: none
    }

    a:hover {
      text-decoration: underline
    }

    .layout {
      display: grid;
      grid-template-columns: 320px 1fr;
      gap: 0;
      min-height: 100%
    }

    nav {
      position: sticky;
      top: 0;
      align-self: start;
      height: 100svh;
      overflow: auto;
      background: var(--panel);
      border-right: 1px solid var(--border);
      padding: 18px 14px;
    }

    nav h2 {
      margin: 0 0 10px 6px;
      font-size: 18px;
      font-weight: 700;
      letter-spacing: .2px
    }

    .search {
      position: sticky;
      top: 0;
      background: var(--panel);
      padding-bottom: 8px
    }

    .toc {
      list-style: none;
      margin: 10px 0 50px;
      padding: 0
    }

    .toc>li {
      margin-bottom: 10px
    }

    .toc a {
      display: block;
      padding: 6px 10px;
      border-radius: 10px;
      color: var(--muted)
    }

    .toc a.active {
      background: rgba(122, 162, 255, .14);
      color: var(--ink)
    }

    .toc details {
      margin: 4px 0 6px 6px
    }

    .toc summary {
      cursor: pointer;
      padding: 6px 10px;
      border-radius: 10px;
      color: var(--muted)
    }

    .toc ol {
      list-style: none;
      padding-left: 14px;
      margin: 6px 0
    }

    .toc ol a {
      font-size: 14px
    }

    main {
      padding: 32px 10vw 80px 48px
    }

    section {
      padding-bottom: 28px;
      margin-bottom: 28px;
      border-bottom: 1px dashed var(--border);
      background: var(--surface);
      padding: 23px;
      height: calc(100vh - 150px);
      overflow: auto;
      position: relative;
    }

    h1 {
      font-size: 34px;
      margin: .2em 0 .2em
    }

    h2 {
      font-size: 24px;
      margin: 1.6em 0 .4em
    }

    h3 {
      font-size: 18px;
      margin: 1.1em 0 .2em;
      color: var(--muted)
    }

    p {
      margin: .4em 0
    }

    .tip {
      border-left: 3px solid var(--accent-2);
      background: rgba(51, 214, 166, .08);
      padding: 10px 12px;
      border-radius: 8px;
      margin: 10px 0
    }

    pre {
      background: var(--code);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 14px;
      overflow: auto;
      position: relative;
    }

    code,
    pre,
    kbd {
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace
    }

    .pill {
      display: inline-block;
      padding: 2px 8px;
      border: 1px solid var(--border);
      border-radius: 999px;
      font-size: 12px;
      color: var(--muted)
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      gap: 14px
    }

    .small {
      font-size: 14px;
      color: var(--muted)
    }

    footer {
      color: var(--muted);
      font-size: 13px;
      margin-top: 36px
    }

    .top {
      position: fixed;
      right: 18px;
      bottom: 18px;
      background: var(--accent);
      color: #091024;
      border: none;
      border-radius: 999px;
      padding: 10px 14px;
      cursor: pointer;
      box-shadow: 0 10px 40px rgba(122, 162, 255, .35)
    }

    /* Light theme overrides */
    [data-theme="light"] {
      --bg: #f7f8fc;
      --panel: #ffffff;
      --ink: #0b1020;
      --muted: #4a5568;
      --accent: #1a56db;
      --accent-2: #10b981;
      --border: #e2e8f0;
      --code: #f1f5f9;
      --surface: #ffffff;
    }

    .search input.toc-input {
      width: 93%;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: var(--code);
      color: var(--ink);
    }

    .theme-toggle {
      margin-top: 8px;
      width: auto;
      padding: 4px 6px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: transparent;
      color: var(--ink);
      cursor: pointer;
      position: absolute;
      top: -9px;
      right: 0;
    }

    span.pagenum {
      position: absolute;
      right: 10px;
      background: var(--bg);
      padding: 5px 13px;
      border-radius: 5px;
      margin-bottom: 3px;
      display: block;
      top: 11px;
    }

    .code-tools {
      position: absolute;
      top: 10px;
      right: 10px;
      display: flex;
      flex-direction: row;
      align-content: space-around;
      justify-content: center;
      align-items: stretch;
      gap: 10px;
    }


    /* Mobile nav trigger + backdrop */
    .mobile-menu {
      position: fixed;
      left: 12px;
      top: 12px;
      z-index: 60;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: var(--panel);
      color: var(--ink);
      cursor: pointer;
      display: none;
      /* shown on mobile below */
    }

    .backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, .45);
      z-index: 55;
    }

    /* Improve code-tool buttons on touch */
    .code-tools button {
      padding: 6px 10px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: var(--panel);
      color: var(--ink);
      cursor: pointer;
    }

    pre code.editing {
      outline: 2px dashed var(--accent);
      outline-offset: 4px
    }

    /* Responsive */
    @media (max-width: 900px) {
      .mobile-menu {
        display: inline-block
      }

      .layout {
        grid-template-columns: 99% 1fr;
      }

      /* stack */
      main {
        padding: 72px 16px 80px 16px
      }

      /* space for top menu button */
      header h1 {
        font-size: 26px
      }

      h2 {
        font-size: 20px
      }

      h3 {
        font-size: 16px
      }

      /* Sections: full width, let them grow naturally */
      section {
        height: auto;
        /* override your calc(100vh - 150px) */
        padding: 16px;
        margin-bottom: 16px;
      }

      .grid {
        grid-template-columns: 1fr
      }

      /* single column cards */
      .search input.toc-input {
        width: 100%
      }

      .top {
        right: 12px;
        bottom: 12px;
        padding: 8px 12px
      }

      /* Off-canvas nav */
      nav#side-nav {
        position: fixed;
        z-index: 70;
        top: 0;
        left: 0;
        width: min(86vw, 340px);
        height: 100vh;
        transform: translateX(-105%);
        transition: transform .25s ease;
        border-right: 1px solid var(--border);
      }

      nav#side-nav.open {
        transform: translateX(0)
      }

      /* Make details summary larger for touch */
      .toc summary,
      .toc a {
        padding: 10px 12px;
      }
    }

    /* Tiny phones */
    @media (max-width: 400px) {
      pre {
        font-size: 13px
      }

      .code-tools {
        gap: 6px
      }
    }
  </style>
</head>

<body>
  <button id="mobile-menu" class="mobile-menu" aria-controls="side-nav" aria-expanded="false">‚ò∞ Menu</button>
  <div id="backdrop" class="backdrop" hidden></div>
  <div class="layout">
    <nav id="side-nav">
      <div class="search">
        <h2>Navigator</h2>
        <input id="toc-filter" class="toc-input" placeholder="Filter topics‚Ä¶" />
        <button id="theme-toggle" class="theme-toggle" aria-label="Toggle color scheme">üåô Dark</button>
      </div>
      <ul class="toc" id="toc">
        <!-- PART 1 -->
        <li><a href="#part1" class="active">PART 1 ¬∑ An Introduction to JS</a>
          <details open>
            <summary>Fundamentals</summary>
            <ol>
              <li><a href="#hello-world">Hello, world!</a></li>
              <li><a href="#code-structure">Code structure</a></li>
              <li><a href="#use-strict">"use strict"</a></li>
              <li><a href="#variables">Variables</a></li>
              <li><a href="#data-types">Data types</a></li>
              <li><a href="#interaction">Interaction: alert/prompt/confirm</a></li>
              <li><a href="#type-conversions">Type Conversions</a></li>
              <li><a href="#operators">Basic operators & maths</a></li>
              <li><a href="#comparisons">Comparisons</a></li>
              <li><a href="#conditionals">Conditionals: if / ?</a></li>
              <li><a href="#logic">Logical operators</a></li>
              <li><a href="#nullish">Nullish coalescing ??</a></li>
              <li><a href="#loops">Loops: while / for</a></li>
              <li><a href="#switch">switch</a></li>
              <li><a href="#functions">Functions (declaration, params)</a></li>
              <li><a href="#func-expr">Function expressions</a></li>
              <li><a href="#arrows">Arrow functions</a></li>
            </ol>
          </details>
        </li>

        <!-- PART 2 -->
        <li><a href="#part2">PART 2 ¬∑ Code Quality</a>
          <details>
            <summary>Practices</summary>
            <ol>
              <li><a href="#debugging">Debugging in the browser</a></li>
              <li><a href="#style">Coding Style</a></li>
            </ol>
          </details>
        </li>

        <!-- PART 3 -->
        <li><a href="#part3">PART 3 ¬∑ Advanced Topics</a>
          <details>
            <summary>Language APIs</summary>
            <ol>
              <li><a href="#array-methods">Array methods</a></li>
              <li><a href="#map-set">Map & Set</a></li>
              <li><a href="#objects">Objects</a></li>
              <li><a href="#object-entries">Object.keys / values / entries</a></li>
              <li><a href="#date-time">Date & time</a></li>
              <li><a href="#json">JSON & toJSON</a></li>
              <li><a href="#timers">setTimeout / setInterval</a></li>
              <li><a href="#function-binding">Function binding</a></li>
              <li><a href="#try-catch">Error handling</a></li>
              <li><a href="#promises">Promises & async/await</a></li>
              <li><a href="#promise-errors">Promise error handling</a></li>
              <li><a href="#promise-api">Promise API</a></li>
              <li><a href="#async-await">Async/await patterns</a></li>
            </ol>
          </details>
        </li>

        <!-- PART 4 -->
        <li><a href="#part4">PART 4 ¬∑ DOM</a>
          <details>
            <summary>Browser & DOM</summary>
            <ol>
              <li><a href="#browser-env">Browser environment & specs</a></li>
              <li><a href="#dom-tree">DOM tree</a></li>
              <li><a href="#walking">Walking the DOM</a></li>
              <li><a href="#searching">Searching elements</a></li>
              <li><a href="#node-props">Node properties</a></li>
              <li><a href="#attrs-props">Attributes vs properties</a></li>
              <li><a href="#modifying">Modifying the document</a></li>
              <li><a href="#styles-classes">Styles & classes</a></li>
              <li><a href="#events">Browser events</a></li>
            </ol>
          </details>
        </li>

        <!-- PART 5 -->
        <li><a href="#part5">PART 5 ¬∑ Network Requests</a>
          <details>
            <summary>HTTP APIs</summary>
            <ol>
              <li><a href="#fetch">Fetch</a></li>
              <li><a href="#formdata">FormData</a></li>
              <li><a href="#fetch-api">Fetch API patterns</a></li>
              <li><a href="#url">URL objects</a></li>
              <li><a href="#xhr">XMLHttpRequest</a></li>
            </ol>
          </details>
        </li>

        <!-- PART 6 -->
        <li><a href="#part6">PART 6 ¬∑ Browser Storage</a>
          <details>
            <summary>Persistence</summary>
            <ol>
              <li><a href="#cookies">Cookies</a></li>
              <li><a href="#storage">localStorage / sessionStorage</a></li>
              <li><a href="#indexeddb">IndexedDB</a></li>
            </ol>
          </details>
        </li>
      </ul>
      <div class="small">Tip: use the filter box to quickly jump to a topic.</div>
    </nav>

    <main>
      <header>
        <h1>JavaScript Fundamentals ¬∑ Complete Notes & Examples</h1>
        <p class="small">Each topic below gives a quick explanation and at least one example. Copy/paste and run in your
          browser DevTools console (<kbd>F12</kbd> or <kbd>Ctrl/‚åò+Shift+I</kbd>).</p>
        <p class="pill">Beginner ‚Üí Intermediate ¬∑ ES2023-friendly</p>
      </header>

      <!-- PART 1 -->
      <section id="part1">
        <h2>PART 1 ¬∑ An Introduction to JavaScript</h2>
        <p>
          JavaScript was initially created to ‚Äúmake web pages alive‚Äù.
          <br><br>
          The programs in this language are called scripts. They can be written right in a web page‚Äôs HTML and run
          automatically as the page loads.
          <br><br>
          Scripts are provided and executed as plain text. They don‚Äôt need special preparation or compilation to run.
        </p>
        <h4>JavaScript is able to:</h4>
        <ul>
          <li>Add new HTML to the page, change the existing content, modify styles.</li>
          <li>React to user actions, run on mouse clicks, pointer movements, key presses.</li>
          <li>Send requests over the network to remote servers, download and upload files (so-called <a
              href="https://en.wikipedia.org/wiki/Ajax_(programming)">AJAX</a></li>
          <li>Get and set cookies, ask questions to the visitor, show messages.</li>
          <li>Remember the data on the client-side (‚Äúlocal storage‚Äù).</li>
        </ul>
        <h4>What makes JavaScript unique?</h4>
        <ul>
          <li>Full integration with HTML/CSS.</li>
          <li>Simple things are done simply.</li>
          <li>Supported by all major browsers and enabled by default.</li>


        </ul>
      </section>

      <section id="hello-world">
        <h3>Hello, world!</h3>
        <p>Use a <code>&lt;script&gt;</code> tag to run JavaScript on a page, or open the DevTools console and type code
          directly.</p>
        <pre><code>&lt;script type="text/javascript" &gt;
  alert('Hello, world!');
&lt;/script&gt;</code></pre>
        <div class="tip">In HTML, put complex scripts in external <code>.js</code> files for caching and reuse.</div>
        <pre><code>&lt;script type="text/javascript" src="script.js"&gt;&lt;/script&gt;</code>
        </pre>

      </section>

      <section id="code-structure">
        <h3>Code structure: statements, semicolons, comments</h3>
        <p>Write one statement per line; semicolons are optional but recommended. Use <code>//</code> or
          <code>/* ... */</code> for comments.
        </p>
        <pre><code>// Two statements:
const msg = 'JS!'; 
alert(msg);   // shows "JS!"</code></pre>
      </section>

      <section id="use-strict">
        <h3>The modern mode: <code>"use strict"</code> (Should we use it?)</h3>
        <p><code>"use strict"</code> enables safer, modern semantics (e.g., forbids accidental globals). Yes‚Äîuse it at
          the top of files.</p>
        <pre><code>"use strict";
x = 1; // ReferenceError in strict mode</code></pre>

        <h4>Why using <code>"use strict"</code>?</h4>
        <p>Enables stricter error checking, improves performance, and prepares for future language features.
          It‚Äôs a good practice to use <code>"use strict"</code> in all your scripts.
        </p>
      </section>

      <section id="variables">
        <h3>Variables</h3>
        <p>Use <code>let</code> for reassignable bindings, <code>const</code> for constants. Prefer clear, descriptive
          names.</p>
        <pre><code>const TAX_RATE = 0.18;
let subtotal = 100;
let total = subtotal * (1 + TAX_RATE);</code></pre>

        <h4>Variable naming</h4>
        <ul>
          <li>Use <code>camelCase</code> for multi-word names (e.g., <code>myVariable</code>).</li>
          <li>Start with a letter, $, or _. Avoid numbers at the beginning.</li>
          <li>Be descriptive but concise (e.g., <code>itemCount</code> instead of <code>ic</code>).</li>
        </ul>
      </section>

      <section id="data-types">
        <h3>Data types</h3>
        <p>A value in JavaScript is always of a certain type. For example, a string or a number.</p>
        <p>Primitives: number, string, boolean, null, undefined, bigint, symbol ¬∑ Reference: object.</p>
        <pre><code>typeof 42           // "number"
typeof 'hi'         // "string"
typeof null         // "object" (quirk)
typeof {}           // "object"</code></pre>
      </section>

      <section id="interaction">
        <h3>Interaction: <code>alert</code>, <code>prompt</code>, <code>confirm</code></h3>
        <div class="">
          <div>
            <p>Use <code>alert</code> to show a message.</p>
            <pre><code>alert('Heads up!');</code></pre>
          </div>
          <div>
            <p>Use <code>prompt</code> to ask for input.</p>
            <pre><code>const name = prompt('Your name?','');
alert('Hi, ' + name + '!');</code></pre>
          </div>
          <div>
            <p>Use <code>confirm</code> to ask for a yes/no answer.</p>
            <pre><code>const ok = confirm('Continue?');
alert(ok ? 'Proceeding' : 'Stopped');</code></pre>
          </div>
        </div>
      </section>

      <section id="type-conversions">
        <h3>Type Conversions</h3>
        <p>Convert explicitly with <code>Number(x)</code>, <code>String(x)</code>, <code>Boolean(x)</code>. Beware:
          <code>+</code> concatenates if either side is a string.
        </p>
        <pre><code>Number(' 42 ')      // 42
'4' + 2             // "42"  (concat)
'4' - 2             // 2     (numeric)</code></pre>
      </section>

      <section id="operators">
        <h3>Basic operators & maths</h3>
        <p>Standard arithmetic, assignment, and exponentiation <code>**</code>. The unary <code>+</code> coerces to
          number.</p>
        <pre><code>+true     // 1
2 ** 3    // 8 //exponentiation
let x = 2; x *= 3 + 1; // 8 </code></pre>
        <h4>Arithmetic operators</h4>
        <ul>
          <li>Addition <code>+</code>,</li>
          <li>Subtraction <code>-</code>,</li>
          <li>Multiplication <code>*</code>,</li>
          <li>Division <code>/</code>,</li>
          <li>Remainder <code>%</code>,</li>
          <li>Exponentiation <code>**</code>.</li>
        </ul>
      </section>

      <section id="comparisons">
        <h3>Comparisons</h3>
        <p>Use <code>===</code>/<code>!==</code> for strict checks (no type coercion). Strings compare
          lexicographically.</p>
        <pre><code>'Z' > 'A'         // true
0 == false        // true
0 === false       // false (strict)</code></pre>
      </section>

      <section id="conditionals">
        <h3>Conditional branching: <code>if</code>, <code>?</code></h3>

        <p>The if(...) statement evaluates a condition in parentheses and, if the result is true, executes a block of
          code</p>
        <p>For example:</p>
        <pre>
          <code>
            if(age >= 18) {
                alert('adult');
            } else {
                alert('minor');
            }</code>
        </pre>

        <p>You can use the <code>?</code> operator for a shorter way to write an <code>if</code> statement. For example:
        </p>
        <pre><code>const age = 20;
const label = age &gt;= 18 ? 'adult' : 'minor';</code></pre>
      </section>

      <section id="logic">
        <h3>Logical operators: OR / AND / NOT</h3>
        <p><code>||</code> returns the first truthy; <code>&amp;&amp;</code> returns the first falsy; <code>!</code>
          negates.</p>
        <pre><code>'' || 'fallback'     // "fallback"
'hi' &amp;&amp; 123          // 123
!0                   // true</code></pre>
      </section>

      <section id="nullish">
        <h3>Nullish coalescing: <code>??</code></h3>
        <p>Return the right side only when the left is <em>null</em> or <em>undefined</em> (unlike <code>||</code>,
          which treats many values as ‚Äúfalsy‚Äù).</p>


        <p>
          Historically, the OR || operator was there first. It‚Äôs been there since the beginning of JavaScript, so
          developers were using it for such purposes for a long time.

          On the other hand, the nullish coalescing operator ?? was added to JavaScript only recently, and the reason
          for that was that people weren‚Äôt quite happy with ||.

          The important difference between them is that:
        <ul>
          <li><code>||</code> returns the first truthy value.</li>
          <li><code>??</code> returns the first defined value (ignores only <code>null</code> and
            <code>undefined</code>).
          </li>
        </ul>

        <pre><code>let height = 0;
alert(height || 100); // 100
alert(height ?? 100); // 0</code></pre>

        <ul>
          <li>The nullish coalescing operator <code>??</code> provides a short way to choose the first ‚Äúdefined‚Äù value
            from a list.</li>
          <li>It‚Äôs used to assign default values to variables.</li>
          <li>The operator <code>??</code> has a very low precedence, only a bit higher than <code>?</code> and
            <code>=</code>, so consider adding parentheses when using it in an expression.
          </li>
          <li>It‚Äôs forbidden to use it with <code>||</code> or <code>&amp;&amp;</code> without explicit parentheses.
          </li>
        </ul>

        </p>
        <p>
          <a href="https://www.youtube.com/watch?v=TOBlbEe224Q" target="_blank">Nullish Coalescing (??) in 2 Minutes
          </a>
        </p>
      </section>

      <section id="loops">
        <h3>Loops: <code>while</code>, <code>for</code></h3>
        <p>Loops are a way to repeat the same code multiple times.</p>
        <pre><code>while (condition) {
  // code
  // so-called "loop body"
}</code>

<code>do {
  // loop body
} while (condition);</code>
</pre>

        <p>Examples</p>
        <pre><code>let i = 0;
while (i < 3) { // shows 0, then 1, then 2
  alert( i );
  i++;
}</code></pre>

        <pre><code>let i = 0;
do {
  alert( i );
  i++;
} while (i < 3);</code></pre>


        <pre><code>for (let i = 0; i < 3; i++) { // shows 0, then 1, then 2
  alert(i);
}</code></pre>

        <h4>Breaking the loop</h4>
        <p>Normally, a loop exits when its condition becomes falsy.

          But we can force the exit at any time using the special break directive.</p>
        <pre><code>let sum = 0;

while (true) {
  let value = +prompt("Enter a number", '');
  if (!value) break; // (*)
  sum += value;

}
alert( 'Sum: ' + sum );</code></pre>
        <h4>Continue to the next iteration</h4>
        <p>The continue directive is a ‚Äúlighter version‚Äù of break. It doesn‚Äôt stop the whole loop. Instead, it stops the
          current iteration and forces the loop to start a new one (if the condition allows).</p>
        <pre><code>for (let i = 0; i < 10; i++) {

  // if true, skip the remaining part of the body
  if (i % 2 == 0) continue;

  alert(i); // 1, then 3, 5, 7, 9
}</code></pre>
      </section>

      <section id="switch">
        <h3>The <code>switch</code> statement</h3>
        <p>A switch statement can replace multiple if checks.

          It gives a more descriptive way to compare a value with multiple variants.</p>
        <pre><code>const role = 'admin';
switch (role) {
  case 'user':  /* ... */ break;
  case 'admin': /* ... */ break;
  default:      /* ... */
}</code></pre>
        <p>Example</p>
        <pre><code>let arg = prompt("Enter a value?");
switch (arg) {
  case '0':
   alert( 'Zero' );
  case '1':
    alert( 'One' );
    break;
  case '2':
    alert( 'Two' );
    break;
  case '3':
    alert( 'Three' );
    break;
  default:
    alert( 'An unknown value' );
}</code></pre>
      </section>

      <!-- to do -->
      <section id="functions">
        <h3>Functions (declaration, local/outer vars, params, defaults)</h3>
        <p>Functions are the main ‚Äúbuilding blocks‚Äù of the program. They allow the code to be called many times without
          repetition.

          We‚Äôve already seen examples of built-in functions, like alert(message), prompt(message, default) and
          confirm(question). But we can create functions of our own as well.</p>

        <h4>Function Declaration</h4>

        <p>To create a function we can use a function declaration.</p>
        <p>It looks like this:</p>

        <pre><code>function showMessage() {
  alert( 'Hello everyone!' );
}
showMessage()
</code></pre>

        <p>The function keyword goes first, then goes the name of the function, then a list of parameters between the
          parentheses (comma-separated, empty in the example above, we‚Äôll see examples later) and finally the code of
          the function, also named ‚Äúthe function body‚Äù, between curly braces.</p>
        <h4>Parameters</h4>
        <pre><code>function showMessage(name) {
  let message = "Hello " + name + ", I'm JavaScript!"; // local variable

  alert( message );
}

showMessage('Saeed'); // Hello, I'm JavaScript!
</code>
          </pre>

        <h4>Default values</h4>
        <p>We can specify the so-called ‚Äúdefault‚Äù (to use if omitted) value for a parameter in the function declaration,
          using =:
        </p>
        <pre><code>function showMessage(name = "stranger") {
  let message = "Hello " + name + ", I'm JavaScript!"; // local variable

  alert( message );
}
showMessage("Layla");
showMessage(); 
</code></pre>

        <h4>Returning a value</h4>
        <p>A function can return a value back into the calling code as the result.

          The simplest example would be a function that sums two values:</p>
        <pre><code>function sum(a, b) {
  return a + b;
}

let result = sum(1, 2);
alert( result ); // 3</code></pre>
      </section>

      <section id="func-expr">
        <h3>Function expressions</h3>
        <p>In JavaScript, a function is not a ‚Äúmagical language structure‚Äù, but a special kind of value.

          The syntax that we used before is called a Function Declaration:</p>
        <pre><code>function sayHi() {
  alert( "Hello" );
}
sayHi(); // Hello </code></pre>

        <p>There is another syntax for creating a function that is called a Function Expression.

          It allows us to create a new function in the middle of any expression.</p>

        For example:
        <pre><code>let sayHi = function() {
  alert( "Hello" );
};
sayHi(); // Hello

</code></pre>

        Here we can see a variable sayHi getting a value, the new function, created as function() { alert("Hello"); }.
        <h4>Callback function</h4>

        <pre><code>function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}

function showOk() {
  alert( "You agreed." );
}

function showCancel() {
  alert( "You canceled the execution." );
}

// usage: functions showOk, showCancel are passed as arguments to ask
ask("Do you agree?", showOk, showCancel);</code></pre>
      </section>

      <section id="arrows">
        <h3>Arrow functions</h3>
        <p>There‚Äôs another very simple and concise syntax for creating functions, that‚Äôs often better than Function
          Expressions.
          It‚Äôs called ‚Äúarrow functions‚Äù, because it looks like this:
        <pre><code>let func = (arg1, arg2, ..., argN) => expression;</code></pre>
        <p>This creates a function func that accepts arguments arg1..argN, then evaluates the expression on the right
          side with their use and returns its result.</p>
        <pre><code>let func = function(arg1, arg2, ..., argN) {
  return expression;
};</code></pre>
        <pre><code>function func(arg1, arg2, ..., argN) {
  return expression;
};</code></pre>
        <p>Example:</p>
        <pre><code>let sum = (a, b) => a + b;

/* This arrow function is a shorter form of:
let sum = function(a, b) {
  return a + b;
};
*/

alert( sum(1, 2) ); // 3</code></pre>
        <pre><code>let age = prompt("What is your age?", 18);

let welcome = (age < 18) ?
  () => alert('Hello!') :
  () => alert("Greetings!");

welcome();</code></pre>
        </p>
        <h4>Multiline arrow functions</h4>
        <p>Sometimes we need a more complex function, with multiple expressions and statements. In that case, we can
          enclose them in curly braces. The major difference is that curly braces require a return within them to return
          a value (just like a regular function does).</p>
        <pre><code>let sum = (a, b) => {  // the curly brace opens a multiline function
  let result = a + b;
  return result; // if we use curly braces, then we need an explicit "return"
};

alert( sum(1, 2) ); // 3</code></pre>
      </section>

      <!-- PART 2 -->
      <section id="part2">
        <h2>PART 2 ¬∑ Code Quality</h2>
        <p>
          Code quality in JavaScript refers to the overall standard and effectiveness of the codebase, encompassing its
          readability, maintainability, reliability, security, and performance. High-quality code is easier to
          understand, debug, modify, and extend, leading to more efficient development and reduced technical debt.
        </p>
      </section>

      <section id="debugging">
        <h3>Debugging in the browser</h3>

        <p>
          Debugging is the process of finding and fixing errors within a script. All modern browsers and most other
          environments support debugging tools ‚Äì a special UI in developer tools that makes debugging much easier. It
          also allows to trace the code step by step to see what exactly is going on.

          We‚Äôll be using Chrome here, because it has enough features, most other browsers have a similar process.
        </p>

        <p>Open DevTools, use breakpoints, <code>console.log</code>, and the Sources panel to step through code.</p>

        <pre><code>console.log({value, state});
debugger; // triggers a breakpoint when DevTools is open</code></pre>
      </section>

      <section id="style">
        <h3>Coding Style & Best Practices</h3>
        <p>Writing clean, readable, and maintainable code is crucial. A consistent style helps prevent bugs and makes
          collaboration easier.</p>

        <h4>Variables and Naming</h4>
        <p>Use <code>const</code> by default to prevent accidental reassignment. Use <code>let</code> only when you know
          a variable needs to change. Name variables descriptively.</p>
        <pre><code>// Good: Clear and immutable where possible
const userProfile = await fetchUserProfile(userId);
let retryCount = 0;

// Avoid: Vague, mutable when it doesn't need to be
var data = ...; // 'var' is legacy, prefer let/const
var i = 0;      // 'i' is not descriptive
</code></pre>

        <h4>Functions</h4>
        <p>Functions should be small and do one thing well (Single Responsibility Principle). Avoid deep nesting, which
          makes code hard to follow.</p>
        <pre><code>// Good: Clear, single purpose
function isUserAdmin(user) {
  return user.role === 'admin';
}

// Avoid: Too many nested levels
function processData(data) {
  if (data) {
    if (data.items) {
      // ... more nesting
    }
  }
}</code></pre>

        <h4>Tooling for Consistency</h4>
        <p>Automated tools can format your code and catch common errors, ensuring consistency across your project.</p>
        <ul>
          <li><a href="https://prettier.io/" target="_blank">Prettier</a>: An opinionated code formatter that enforces a
            consistent style.</li>
          <li><a href="https://eslint.org/" target="_blank">ESLint</a>: A static analysis tool to find and fix problems
            in your JavaScript code.</li>
        </ul>
      </section>

      <!-- PART 3 -->
      <section id="part3">
        <h2>PART 3 ¬∑ Advanced Topics</h2>
      </section>

      <section id="array-methods">
        <h3>Array Methods</h3>
        <p>Arrays come with a host of built-in methods to make common operations like iteration, transformation, and
          filtering concise and readable.</p>

        <h4>Iteration: <code>.forEach()</code></h4>
        <p>Executes a provided function once for each array element. It's a modern replacement for a simple
          <code>for</code> loop.
        </p>
        <pre><code>const fruits = ['apple', 'banana', 'cherry'];
fruits.forEach(fruit => {
  alert(`I love ${fruit}s!`);
});
// Logs: "I love apples!", "I love bananas!", "I love cherrys!"</code></pre>

        <h4>Transformation: <code>.map()</code></h4>
        <p>Creates a <strong>new array</strong> populated with the results of calling a provided function on every
          element in the calling array.</p>
        <pre><code>const numbers = [1, 4, 9, 16];
const roots = numbers.map(num => Math.sqrt(num));
// roots is now [1, 2, 3, 4]
alert(roots);
// numbers is still [1, 4, 9, 16]
alert(numbers);
</code></pre>

        <h4>Filtering: <code>.filter()</code></h4>
        <p>Creates a <strong>new array</strong> with all elements that pass the test implemented by the provided
          function.</p>
        <pre><code>const ages = [32, 33, 16, 40];
const adults = ages.filter(age => age >= 18);
alert(adults);
// adults is now [32, 33, 40]</code></pre>

        <h4>Aggregation: <code>.reduce()</code></h4>
        <p>Executes a "reducer" function on each element of the array, resulting in a single output value (e.g., a sum
          or a flattened array).</p>
        <pre><code>const numbers = [1, 2, 3, 4];
const sum = numbers.reduce((accumulator, currentValue) => {
  return accumulator + currentValue;
}, 0); // 0 is the initial value for the accumulator
alert(sum);
// sum is 10</code></pre>

        <h4>Finding Elements: <code>.find()</code> & <code>.some()</code></h4>
        <p><code>.find()</code> returns the first element that satisfies a condition, while <code>.some()</code> returns
          a boolean if at least one element satisfies it.</p>
        <pre><code>const inventory = [ { name: 'apples', quantity: 2 }, { name: 'bananas', quantity: 0 }];
const appleItem = inventory.find(item => item.name === 'apples'); // { name: 'apples', quantity: 2 }
const hasOutOfStock = inventory.some(item => item.quantity === 0); // true
alert(hasOutOfStock);

</code></pre>
      </section>

      <section id="map-set">
        <h3>Map and Set</h3>
        <p><code>Map</code> and <code>Set</code> are modern, specialized data structures that offer more flexibility and
          performance for certain tasks compared to plain Objects and Arrays.</p>

        <h4>Map</h4>
        <p>A <code>Map</code> is a collection of keyed data items, much like an <code>Object</code>. However, the main
          difference is that <code>Map</code> allows keys of any type and maintains the insertion order.</p>
        <pre><code>const userRoles = new Map();

// Set key-value pairs
const john = { name: 'John' };
userRoles.set(john, 'Admin');
userRoles.set('guest', 'Limited Access');

// Get a value by key
alert(userRoles.get(john)); // "Admin"

// Check for existence
  alert(userRoles.has('guest')); // true

alert(userRoles.size); // 2</code></pre>

        <h4>Set</h4>
        <p>A <code>Set</code> is a special type of collection that only stores <strong>unique</strong> values. If you
          add a value that already exists, it will be ignored.</p>
        <pre><code>const uniqueNumbers = new Set();
uniqueNumbers.add(1);
uniqueNumbers.add(5);
uniqueNumbers.add(5); // This duplicate is ignored
uniqueNumbers.add(2);

// A common use case: remove duplicates from an array
const numbers = [2, 3, 4, 4, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7];
const unique = [...new Set(numbers)]; // [2, 3, 4, 5, 6, 7];

alert(unique);
alert(unique.length); // 6
</code></pre>
      </section>


      <section id="objects">
        <h3>Objects</h3>
        <p>
          Objects store keyed collections of data and more complex entities. Unlike primitives (single values),
          objects are mutable containers of <em>properties</em> (key‚Äìvalue pairs). Keys are strings or symbols;
          values can be anything.
        </p>

        <h4>Create objects</h4>
        <pre><code>let user1 = new Object();   // constructor syntax
let user2 = {};             // literal syntax (common)</code></pre>

        <h4>Literals &amp; properties</h4>
        <pre><code>let user = {
  name: "John",
  age: 30
};
// read
alert(user.name); // "John"
alert(user.age);  // 30
// add
user.isAdmin = true;
// delete
delete user.age;</code></pre>

        <h4>Multiword keys &amp; bracket notation</h4>
        <p>Dot notation needs valid identifiers. Use brackets for any string key or when key comes from a variable.</p>
        <pre><code>let user = {};
user["likes birds"] = true;
alert(user["likes birds"]); // true

let key = "likes birds";
alert(user[key]); // true

user.name = "John";
// Dot notation cannot use a variable name as a key:
let k = "name";
alert(user.k); // undefined (looks for literal 'k')
alert(user[k]);</code></pre>
        <h4>Computed properties</h4>
        <p>Build keys dynamically inside object literals.</p>
        <pre><code>let fruit = "apple";
let bag = {
  [fruit]: 5,              // key becomes "apple"
  [fruit + "Computers"]: 2 // key becomes "appleComputers"
};
alert(bag.apple);           // 5
alert(bag.appleComputers);  // 2</code></pre>

        <h4>Property value shorthand</h4>
        <pre><code>function makeUser(name, age){
  return { name, age }; // same as { name: name, age: age }
}
const u = makeUser("John", 30);
alert(u.name); // "John"</code></pre>

        <h4>Property name rules</h4>
        <p>Object property names can be (almost) any string‚Äîeven reserved words or numeric-looking strings.</p>
        <pre><code>let obj = { for: 1, let: 2, return: 3, 0: "zero" };
alert(obj.for + obj.let + obj.return); // 6
alert(obj[0]); // "zero" "zero"
alert(obj["0"]); // "zero" "zero"
</code></pre>

        <div class="tip">Note: <code>__proto__</code> is special; assigning non-objects to it won‚Äôt behave like normal
          props.</div>

        <h4>Check property existence</h4>
        <p>Reading a missing property returns <code>undefined</code>. Use <code>"key" in obj</code> when
          <code>undefined</code> could be a valid value.
        </p>
        <pre><code>let user = {};
alert(user.missing === undefined); // true

let obj2 = { test: undefined };
alert("test" in obj2); // true (property exists)</code></pre>

        <h4>Iterate properties: <code>for...in</code></h4>
        <pre><code>let user = { name: "John", age: 30, isAdmin: true };
for (let key in user) {
  alert(key + ' ' + user[key]);
}</code></pre>

        <h4>Property order</h4>
        <p>Integer-like keys iterate in ascending numeric order; other keys iterate in creation order.</p>
        <pre><code>let codes = { "49": "Germany", "41": "Switzerland", "1": "USA" };
for (let code in codes) alert(code); // 1, 41, 49

let user3 = { name: "John", surname: "Smith" };
user3.age = 25;
for (let k in user3) alert(k); // name, surname, age</code></pre>

        <h4>Summary</h4>
        <ul>
          <li>Objects = key‚Äìvalue stores; keys are strings/symbols, values are any type.</li>
          <li>Access via dot (<code>obj.key</code>) or brackets (<code>obj["key"]</code>); brackets allow variables
            &amp; any string.</li>
          <li>Manage props: <code>obj.key = v</code>, <code>delete obj.key</code>, test with <code>"key" in obj</code>.
          </li>
          <li>Iterate with <code>for...in</code>. Integer-like keys are ordered numerically; others by insertion order.
          </li>
        </ul>
      </section>




      <section id="object-entries">
        <h3>Object.keys / values</h3>
        <p>These methods are used to retrieve different aspects of an object's properties.</p>
        <pre><code>const person = {
  name: 'Alice',
  age: 30,
  city: 'New York'
};

// Object.keys returns an array of keys
const keys = Object.keys(person);
alert(keys); // ['name', 'age', 'city']

// Object.values returns an array of values
const values = Object.values(person);
alert(values); // ['Alice', 30, 'New York']

 
      </section>

      <section id="date-time">
        <h3>Date &amp; Time (Summary)</h3>
        <p>
          JavaScript represents date/time with the built-in <code>Date</code> object. A Date always has
          both date and time. Months are 0‚Äì11 (Jan=0). <code>getDay()</code> returns 0‚Äì6 (Sun=0).
          Dates ‚Äúauto-correct‚Äù when you set out-of-range parts (useful for adding days/months).
        </p>

        <h4>Create dates</h4>
        <pre><code>// Current date/time
let now = new Date();
alert(now);

// From timestamp (ms since Jan 1, 1970 UTC)
let jan01_1970 = new Date(0);
alert(jan01_1970);

let jan02_1970 = new Date(24 * 3600 * 1000);
alert(jan02_1970);

// Before 1970: negative timestamps
let dec31_1969 = new Date(-24 * 3600 * 1000);
alert(dec31_1969);

// From ISO-like string (parsed similar to Date.parse)
let d1 = new Date("2017-01-26");
alert(d1);

// From parts (year, month(0-11), date, hours, minutes, seconds, ms)
let d2 = new Date(2011, 0, 1, 2, 3, 4, 567);
alert(d2);</code></pre>

        <h4>Read components (local time)</h4>
        <pre><code>let d = new Date();
alert(d.getFullYear());   // e.g., 2025
alert(d.getMonth());      // 0..11
alert(d.getDate());       // 1..31
alert(d.getDay());        // 0..6 (Sun..Sat)
alert(d.getHours());      // 0..23
alert(d.getMinutes());    // 0..59
alert(d.getSeconds());    // 0..59
alert(d.getMilliseconds());// 0..999

// UTC variants: getUTCFullYear(), getUTCMonth(), getUTCHours()...
alert(d.getUTCHours());   // hour in UTC</code></pre>

        <h4>Set components (auto-correct applies)</h4>
        <pre><code>let today = new Date();

// Change just the hour
today.setHours(0);
alert(today);

// Set exact time to 00:00:00.000
today.setHours(0, 0, 0, 0);
alert(today);</code></pre>

        <h4>Autocorrection (handy for adding time)</h4>
        <pre><code>let date = new Date(2013, 0, 32); // Jan 32, 2013 ?!
alert(date); // auto-corrects to Feb 1, 2013

let leap = new Date(2016, 1, 28);       // Feb 28, 2016
leap.setDate(leap.getDate() + 2);       // add 2 days
alert(leap); // Mar 1, 2016</code></pre>

        <h4>Timestamps &amp; differences</h4>
        <pre><code>let start = new Date();
// do some work
for (let i = 0; i &lt; 100000; i++) { let x = i * i * i; }
let end = new Date();

alert("The loop took " + (end - start) + " ms"); // subtracting dates = ms diff
alert(+end); // number conversion ‚Üí timestamp (same as end.getTime())</code></pre>

        <h4>Fast now (no Date object)</h4>
        <pre><code>let t1 = Date.now(); // ms since Jan 1, 1970
for (let i = 0; i &lt; 100000; i++) { let x = i * i * i; }
let t2 = Date.now();
alert("The loop took " + (t2 - t1) + " ms");</code></pre>

        <h4>Parsing strings</h4>
        <pre><code>// ISO-like format: YYYY-MM-DDTHH:mm:ss.sssZ (Z or ¬±hh:mm)
let ms = Date.parse("2012-01-26T13:51:50.417-07:00");
alert(ms);                        // timestamp (ms)
let parsed = new Date(ms);        // make Date from it
alert(parsed);</code></pre>

        <h4>Key points</h4>
        <ul>
          <li><code>Date</code> always includes both date and time.</li>
          <li>Months are zero-based; <code>getDay()</code>: Sun=0..Sat=6.</li>
          <li>Setting out-of-range parts auto-adjusts the date.</li>
          <li>Subtract Dates (or use <code>Date.now()</code>) to measure durations.</li>
        </ul>
      </section>


      <section id="json">
        <h3>JSON methods &amp; <code>toJSON</code> (Summary)</h3>
        <p>
          <strong>JSON</strong> is a data format for exchanging structured data. In JS, use
          <code>JSON.stringify</code> to serialize values ‚Üí string, and <code>JSON.parse</code> to read
          them back. JSON supports objects, arrays, strings, numbers, booleans, and <code>null</code>.
          (Functions, <code>undefined</code>, and symbol properties are skipped.)
        </p>

        <h4>Stringify basics</h4>
        <pre><code>let student = {
  name: "John",
  age: 30,
  isAdmin: false,
  courses: ["html","css","js"],
  spouse: null
};

let json = JSON.stringify(student);   // ‚Üí string
alert(typeof json);                   // "string"
alert(json);
/* Example output:
{"name":"John","age":30,"isAdmin":false,"courses":["html","css","js"],"spouse":null}
*/</code></pre>

        <h4>Primitives also stringify</h4>
        <pre><code>alert(JSON.stringify(1));           // 1
alert(JSON.stringify("test"));     // "test"
alert(JSON.stringify(true));       // true
alert(JSON.stringify([1,2,3]));    // [1,2,3]</code></pre>

        <h4>Skipped in JSON</h4>
        <pre><code>let user = {
  sayHi(){ alert("Hello"); },   // function ‚Üí skipped
  [Symbol("id")]: 123,          // symbol ‚Üí skipped
  something: undefined          // undefined ‚Üí skipped
};
alert(JSON.stringify(user));     // "{}"</code></pre>

        <h4>Nested objects (ok) &amp; circular refs (error)</h4>
        <pre><code>let room = { number: 23 };
let meetup = { title: "Conference", place: room };
room.occupiedBy = meetup; // circular link
try {
  JSON.stringify(meetup);
} catch (e) {
  alert("Error: " + e.message);  // Converting circular structure to JSON
}</code></pre>

        <h4>Filtering/transforming: <code>replacer</code></h4>
        <p>
          Use an array of allowed keys, or a function <code>(key, value) =&gt; newValue</code>.
        </p>
        <pre><code>let room2 = { number: 23 };
let meetup2 = {
  title: "Conference",
  participants: [{name:"John"},{name:"Alice"}],
  place: room2
};
room2.occupiedBy = meetup2;

// Keep only selected keys everywhere:
alert(JSON.stringify(meetup2, ["title","participants","place","name","number"]));
/*
{"title":"Conference","participants":[{"name":"John"},{"name":"Alice"}],"place":{"number":23}}
*/

// Or use a replacer function to drop circular ref:
alert(JSON.stringify(meetup2, function replacer(key, value){
  if (key === "occupiedBy") return undefined;
  return value;
}));</code></pre>

        <h4>Pretty printing: <code>space</code></h4>
        <pre><code>let userPretty = { name:"John", age:25, roles:{ isAdmin:false, isEditor:true } };
let pretty = JSON.stringify(userPretty, null, 2); // 2-space indent
alert(pretty);
/* 
{
  "name": "John",
  "age": 25,
  "roles": {
    "isAdmin": false,
    "isEditor": true
  }
}
*/</code></pre>

        <h4>Custom <code>toJSON</code></h4>
        <pre><code>let room3 = {
  number: 23,
  toJSON(){ return this.number; } // define your own JSON form
};
let meetup3 = { title: "Conference", room: room3 };

alert(JSON.stringify(room3));   // 23
alert(JSON.stringify(meetup3)); // {"title":"Conference","room":23}</code></pre>

        <h4>Parsing strings: <code>JSON.parse</code></h4>
        <pre><code>let numbers = "[0,1,2,3]";
let arr = JSON.parse(numbers);
alert(arr[1]); // 1

let userData = '{"name":"John","age":35,"isAdmin":false,"friends":[0,1,2,3]}';
let userObj = JSON.parse(userData);
alert(userObj.friends[1]); // 1</code></pre>

         

        <h4>Key points</h4>
        <ul>
          <li><code>JSON.stringify(value, replacer?, space?)</code> ‚Üí string.</li>
          <li><code>JSON.parse(str, reviver?)</code> ‚Üí value; use <em>reviver</em> to restore types like
            <code>Date</code>.
          </li>
          <li>If an object has <code>toJSON</code>, it‚Äôs used automatically during stringify.</li>
        </ul>
      </section>


      <section id="timers">
  <h3>Scheduling (Summary): <code>setTimeout</code> &amp; <code>setInterval</code></h3>
  <p>
    Schedule code to run later. <code>setTimeout(fn, ms)</code> runs once after <em>ms</em>. 
    <code>setInterval(fn, ms)</code> repeats every <em>ms</em> until canceled. 
    Delays are approximate (CPU load, background tabs, battery saver, etc.).
  </p>

  <h4>Run once: <code>setTimeout</code></h4>
  <pre><code>
let tId = setTimeout(() => alert("John"), 1000); // 1s later ‚Üí "Hi, John!"
 </code></pre>

  <h4>Repeat: <code>setInterval</code> (and stop)</h4>
  <pre><code>let ticks = 0;
let iId = setInterval(() =&gt; {
  alert("tick " + (++ticks));
  if (ticks === 3) { clearInterval(iId); alert("stop"); }
}, 1500); // every 1.5s</code></pre>

 

  <h4>‚ÄúASAP‚Äù after current script</h4>
  <pre><code>setTimeout(() =&gt; alert("World")); // queued
alert("Hello");                    // shows first</code></pre>

  <div class="tip small">
    Notes: After ~5 nested timers, browsers enforce a ‚â•4ms minimum. Don‚Äôt pass strings (e.g. <code>"alert('x')"</code>); pass functions.
  </div>
</section>

<section id="function-binding">
  <h3>Function Binding (Short Summary)</h3>
  <p>
    When we pass object methods (e.g. to <code>setTimeout</code>), 
    <code>this</code> can be lost ‚Äî it no longer refers to the original object.  
    <code>bind()</code> fixes that by locking the function‚Äôs <code>this</code> value.
  </p>

  <h4>Lost <code>this</code></h4>
  <pre><code>let user = {
  firstName: "John",
  sayHi() { alert("Hi, " + this.firstName); }
};

setTimeout(user.sayHi, 1000); // ‚ùå "Hi, undefined"</code></pre>

  <h4>Fix 1: wrapper function</h4>
  <pre><code>let user = {
  firstName: "John",
  sayHi() { alert("Hi, " + this.firstName); }
};

setTimeout(() => user.sayHi(), 1000); // ‚úÖ "Hi, John"</code></pre>

  <h4>Fix 2: <code>bind()</code></h4>
  <pre><code>let user = {
  firstName: "John"
};

function func() {
  alert(this.firstName);
}

let funcUser = func.bind(user);
funcUser(); // John</code></pre>

 

  <ul>
    <li><code>bind(thisArg)</code> fixes the value of <code>this</code>.</li>
     <li>Use <code>bind</code> when passing methods as callbacks.</li>
  </ul>

   
</section>

      <section id="try-catch">
  <h3>Error handling (Summary): <code>try...catch</code></h3>
  <p>
    Use <code>try...catch</code> to prevent crashes on runtime errors and handle them gracefully.
    Optional <code>finally</code> runs whether an error happened or not.
  </p>

  <h4>Basic pattern</h4>
  <pre><code>try {
  alert("Start");
  lalala;                 // runtime error
  alert("Never runs");
} catch (err) {
  alert(err.name + ": " + err.message); // e.g., "ReferenceError: lalala is not defined"
} finally {
  alert("Cleanup always runs");
}</code></pre>

  <h4>Throw your own errors</h4>
  <pre><code>let json = '{ "age": 30 }';
try {
  let user = JSON.parse(json);
  if (!user.name) throw new SyntaxError("Incomplete data: no name");
  alert("User: " + user.name);
} catch (err) {
  alert("JSON Error: " + err.message);
}</code></pre>

  

</section>


      <section id="promises">
  <h3>Promises (Short Summary)</h3>
  <p>
    A <code>Promise</code> links slow ‚Äúproducing‚Äù code to ‚Äúconsuming‚Äù code.
    It starts <em>pending</em> and settles once: <em>fulfilled</em> via <code>resolve</code> or <em>rejected</em> via <code>reject</code>.
    Use <code>.then</code> for success, <code>.catch</code> for errors, and <code>.finally</code> for cleanup.
  </p>

  <h4>Create</h4>
  <pre><code>let p = new Promise((resolve, reject) => {
  // async work...
  setTimeout(() => resolve("done"), 500); // or: reject(new Error("oops"))
});</code></pre>

  <h4>Consume</h4>
  <pre><code>p.then(result => alert(result))         // "done"
 .catch(err => alert(err))              // "Error: oops"
 .finally(() => alert("finished"));     // always runs</code></pre>

  <h4>One result only</h4>
  <pre><code>new Promise(r => { r("A"); r("B"); })  // "B" is ignored</code></pre>

  <h4>Handlers can be added anytime</h4>
  <pre><code>let ready = Promise.resolve("OK");
ready.then(v => alert(v)); // alerts immediately</code></pre>

  <h4>Mini example: load script</h4>
  <pre><code>function loadScript(src) {
  return new Promise((resolve, reject) => {
    const s = document.createElement("script");
    s.src = src;
    s.onload = () => resolve(s);
    s.onerror = () => reject(new Error("Load error: " + src));
    document.head.append(s);
  });
}

loadScript("https://example.com/app.js")
  .then(s => alert(s.src + " loaded"))
  .catch(e => alert(e.message))
  .finally(() => alert("done"));


loadScript("https://portal.almasar101.com/wp-includes/js/jquery/ui/core.min.js?ver=1.13.3")
  .then(s => alert(s.src + " loaded"))
  .catch(e => alert(e.message))
  .finally(() => alert("done"));



</code></pre>

<a href="https://www.youtube.com/watch?v=y2X196MIuRo" target="_blank">Watch Promise Video Explanation Arabic</a>
<br>
<a href="https://www.youtube.com/watch?v=li7FzDHYZpc" target="_blank">Watch Promise Video Explanation English</a>
</section>


      <section id="promise-chaining">
        <h3>Promise chaining</h3>
        <p>Chaining promises allows you to perform sequential asynchronous operations. Each <code>.then</code> handler receives the result of the previous one, and you can return a new value or a promise to pass it to the next handler.</p>
        <pre><code>new Promise(function(resolve, reject) {

  setTimeout(() => resolve(1), 1000); // (*)

}).then(function(result) { // (**)

  alert(result); // 1
  return result * 2;

}).then(function(result) { // (***)

  alert(result); // 2
  return result * 2;

}).then(function(result) {

  alert(result); // 4
  return result * 2;

});</code></pre>
      </section>

      <section id="promise-error">
  <h3>Error Handling with Promises (Short Summary)</h3>
  <p>
    <code>.catch</code> handles any rejection or error in a promise chain ‚Äî even those thrown in <code>.then</code> handlers.  
    You can place one <code>.catch</code> at the end to handle all errors above.
  </p>

  <h4>Basic example</h4>
  <pre><code>fetch('https://no-such-server.example')
  .then(r => r.json())
  .catch(err => alert("Error: " + err.message));</code></pre>

  <h4>Implicit try...catch</h4>
  <pre><code>new Promise(() => { throw new Error("Whoops!"); })
  .catch(err => alert(err)); // works same as reject()</code></pre>

  <h4>Rethrowing</h4>
  <pre><code>new Promise(() => { throw new Error("Whoops!"); })
  .catch(e => {
    if (e instanceof URIError) alert("Handled");
    else throw e; // pass to next .catch
  })
  .catch(e => alert("Final catch: " + e));</code></pre>

  <h4>Unhandled rejections</h4>
  <pre><code>window.addEventListener("unhandledrejection", e => {
  alert("Unhandled: " + e.reason);
});

new Promise(() => { throw new Error("Whoops!"); });</code></pre>

  <ul>
    <li><code>.catch</code> catches rejections or thrown errors.</li>
    <li>Use <code>throw</code> inside <code>.catch</code> to rethrow unhandled ones.</li>
    <li>Browsers trigger <code>unhandledrejection</code> if a rejected promise has no <code>.catch</code>.</li>
  </ul>
</section>


      <section id="promise-api">
  <h3>Promise API (Short Summary)</h3>
  <p>
    The <code>Promise</code> class has 6 static methods to combine or create promises.  
    They help run tasks in parallel, handle multiple results, or settle early.
  </p>

  <h4>1Ô∏è‚É£ Promise.all</h4>
  <p>Waits for <strong>all</strong> promises to resolve ‚Üí returns array of results.  
     Rejects immediately if any fail.</p>
  <pre><code>Promise.all([
  fetch("https://api.github.com/users/iliakan"), fetch("https://api.github.com/users/zeiadhabbab")
]).then(all => alert("All done"))
  .catch(err => alert("Error: " + err));</code></pre>

  <h4>2Ô∏è‚É£ Promise.allSettled</h4>
  <p>Waits for <strong>all</strong> to finish (fulfilled or rejected). Always resolves with an array of status objects.</p>
  <pre><code>Promise.allSettled([
  fetch("https://api.github.com/users/zeiadhabbab"), fetch("bad.json")
]).then(r => alert(JSON.stringify(r)));</code></pre>

  <h4>3Ô∏è‚É£ Promise.race</h4>
  <p>Resolves/rejects with the <strong>first settled</strong> promise (winner of the ‚Äúrace‚Äù).</p>
  <pre><code>Promise.race([
  new Promise(r => setTimeout(() => r("fast"), 500)),
  new Promise(r => setTimeout(() => r("slow"), 1500))
]).then(alert); // "fast"</code></pre>

  <h4>4Ô∏è‚É£ Promise.any</h4>
  <p>Returns the <strong>first fulfilled</strong> result. If all fail ‚Üí rejects with <code>AggregateError</code>.</p>
  <pre><code>Promise.any([
  Promise.reject("fail"),
  Promise.resolve("ok")
]).then(alert); // "ok"</code></pre>

  <h4>5Ô∏è‚É£ Promise.resolve</h4>
  <p>Creates a resolved promise with a given value.</p>
  <pre><code>Promise.resolve("ready").then(alert);</code></pre>

  <h4>6Ô∏è‚É£ Promise.reject</h4>
  <p>Creates a rejected promise with an error.</p>
  <pre><code>Promise.reject(new Error("Oops")).catch(e => alert(e.message));</code></pre>

  <div class="tip small">
    üí° <strong>Most used:</strong> <code>Promise.all</code> ‚Äì run tasks in parallel and wait for all results.
  </div>
</section>


      <section id="async-await">
  <h3>Async / Await (Short Summary)</h3>
  <p>
    <code>async</code> and <code>await</code> make working with promises simpler and more readable.
    <code>async</code> makes a function return a promise.
    <code>await</code> pauses inside that function until the promise settles.
  </p>

  <h4>Async functions</h4>
  <pre><code>async function f() {
  return 1; // returns Promise.resolve(1)
}
f().then(alert); // 1</code></pre>

  <h4>Await keyword</h4>
  <pre><code>async function f() {
  let promise = new Promise(r => setTimeout(() => r("done!"), 1000));
  let result = await promise; // waits 1s
  alert(result); // "done!"
}
f();</code></pre>

  <h4>Error handling</h4>
  <pre><code>async function f() {
  try {
    let r = await fetch("https://no-site.example");
  } catch (err) {
    alert("Error: " + err.message);
  }
}
f();</code></pre>

  <h4>Await + Promise.all</h4>
  <pre><code>async function loadAll() {
  let [a, b] = await Promise.all([
    fetch("https://api.github.com/users/zeiadhabbab"),
    fetch("https://api.github.com/users/zeiadhabbab")
  ]);
  alert("Both loaded!");
}
loadAll();</code></pre>

  <ul>
    <li><code>async</code> ‚Üí always returns a Promise.</li>
    <li><code>await</code> ‚Üí waits for the promise and gives its result.</li>
    <li>Use <code>try...catch</code> to handle errors inside async functions.</li>
    <li>Combine with <code>Promise.all()</code> for parallel tasks.</li>
  </ul>

  <div class="tip small">
    üí° <strong>Think of:</strong> <code>await</code> = ‚Äúpause until ready‚Äù,  
    <code>async</code> = ‚Äúfunction that always returns a promise‚Äù.
  </div>
  <p>
    <a href="https://www.youtube.com/watch?v=vM58HYbUqC0" target="_blank">Watch Async / Await Video Explanation Arabic</a>
  </p>
  <p>
    <a href="https://www.youtube.com/watch?v=8fWit6bm1sY" target="_blank">Watch Async / Await Video Explanation </a>
  </p>
</section>


      <!-- PART 4 -->
      <section id="part4">
        <h2>PART 4 ¬∑ DOM</h2>
        <p>
          The Document Object Model (DOM) is a programming interface for HTML and XML documents. It represents the page structure as a tree of objects, allowing JavaScript to dynamically access and update content, structure, and styles.
        </p>
        <p>
          This section covers the basics of DOM manipulation, including traversing the DOM tree, searching for elements, modifying content and attributes, handling styles and classes, and working with events.
        </p>
      </section>

      <section id="browser-env">
        <h3>Browser environment & specs</h3>
        <p>The JavaScript language was initially created for web browsers. Since then, it has evolved into a language with many uses and platforms.

A platform may be a browser, or a web-server or another host, or even a ‚Äúsmart‚Äù coffee machine if it can run JavaScript. Each of these provides platform-specific functionality. The JavaScript specification calls that a host environment.

A host environment provides its own objects and functions in addition to the language core. Web browsers give a means to control web pages. Node.js provides server-side features, and so on.</p>
<p>
  There‚Äôs a ‚Äúroot‚Äù object called window. It has two roles:
  <pre><code>function sayHi() {
  alert("Hello");
}

// global functions are methods of the global object:
window.sayHi();</code></pre>
</p>
<pre><code>alert(window.innerHeight); // inner window height</code></pre>

<h3>DOM (Document Object Model)</h3>
<p>The Document Object Model, or DOM for short, represents all page content as objects that can be modified.

The document object is the main ‚Äúentry point‚Äù to the page. We can change or create anything on the page using it.</p>
<pre><code>// change the background color to red
document.body.style.background = "red";

// change it back after 1 second
setTimeout(() => document.body.style.background = "", 1000);</code></pre>

<h3>BOM (Browser Object Model)</h3>
<p>The Browser Object Model (BOM) is a collection of objects that provide browser-specific features. It includes objects like <code>window</code>, <code>navigator</code>, <code>location</code>, <code>history</code>, and <code>screen</code>.</p>

<pre><code>alert(location.href); // shows current URL
if (confirm("Go to Wikipedia?")) {
  location.href = "https://wikipedia.org"; // redirect the browser to another URL
}</code></pre>
          
      </section>

      <section id="dom-tree">
        <h3>DOM tree</h3>
        
        <p>The DOM is a tree of nodes representing the document structure.</p>
        <pre><code>&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;My title&lt;/title&gt;
    &lt;/head&gt;

    &lt;body&gt;
        &lt;a href=&quot;#&quot;&gt;My link&lt;/a&gt;
        &lt;h1&gt;My header&lt;/h1&gt;
    &lt;/body&gt;
&lt;/html&gt;</code></pre>
<img style="height: 400px;" src="https://programiz-pro-spaces.sfo3.digitaloceanspaces.com/programiz-static/programiz-blog/javascript-dom-tree.png" alt="DOM Tree Example">
      
<p><a href="https://software.hixie.ch/utilities/js/live-dom-viewer/">https://software.hixie.ch/utilities/js/live-dom-viewer/</a></p>

 
</section>

      <section id="walking">
        <h3>Walking the DOM</h3>
        <p>To navigate the DOM tree, we can use properties like <code>parentElement</code>, <code>children</code>, <code>firstElementChild</code>, <code>lastElementChild</code>, <code>nextElementSibling</code>, and <code>previousElementSibling</code>.</p>
        <pre><code>const list = document.getElementById('list');
list.firstElementChild.textContent; // "A"</code></pre>

<pre>&lt;html&gt; = document.documentElement</pre>
<pre>&lt;body&gt;  = document.body</pre>
<pre>&lt;head&gt;  = document.head</pre>
<h3>Example</h3>
<pre><code>&lt;html&gt;
&lt;body&gt;
  &lt;div&gt;Begin&lt;/div&gt;

  &lt;ul&gt;
    &lt;li&gt;Information&lt;/li&gt;
  &lt;/ul&gt;

  &lt;div&gt;End&lt;/div&gt;

  &lt;script&gt;
    for (let i = 0; i &lt; document.body.childNodes.length; i++) {
      alert( document.body.childNodes[i] ); // Text, DIV, Text, UL, ..., SCRIPT
    }
  &lt;/script&gt;
  ...more stuff...
&lt;/body&gt;
&lt;/html&gt;</code></pre>

<p>Difference between Node object and Element object?</p>
<p>Node object: represents any part of the document tree, like elements, text, comments, etc.
  <br>
Element object: specifically represents HTML elements and provides methods and properties for manipulating them.</p>

      </section>

      <section id="searching">
        <h3>Searching: <code>getElement*</code>, <code>querySelector*</code></h3>
        <p>To search for elements in the DOM, we can use methods like <code>getElementById</code>, <code>getElementsByTagName</code>, <code>getElementsByClassName</code>, and <code>querySelector</code> (and its plural <code>querySelectorAll</code>).</p>
        <pre><code>&lt;div id=&quot;elem&quot;&gt;
  &lt;div id=&quot;elem-content&quot;&gt;Element&lt;/div&gt;
&lt;/div&gt;

&lt;script&gt;
  // get the element
  let elem = document.getElementById(&#39;elem&#39;);

  // make its background red
  elem.style.background = &#39;red&#39;;
&lt;/script&gt;


        </code></pre>

        <p>Also, there‚Äôs a global variable named by id that references the element:</p>
        <pre><code>&lt;div id=&quot;myDiv&quot;&gt;Hello&lt;/div&gt;
&lt;script&gt;
  alert(myDiv.textContent); // Hello
&lt;/script&gt;</code></pre>

<h3>querySelectorAll</h3>
<p>To select multiple elements, we can use <code>querySelectorAll</code>. It returns a collection of elements that match the given selector.</p>
<pre><code>&lt;ul&gt;
  &lt;li&gt;The&lt;/li&gt;
  &lt;li&gt;test&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
  &lt;li&gt;has&lt;/li&gt;
  &lt;li&gt;passed&lt;/li&gt;
&lt;/ul&gt;
&lt;script&gt;
  let elements = document.querySelectorAll(&#39;ul &gt; li:last-child&#39;);

  for (let elem of elements) {
    alert(elem.innerHTML); // &quot;test&quot;, &quot;passed&quot;
  }
&lt;/script&gt;
</code></pre>


<h3>querySelector</h3>
<p>To select a single element, we can use <code>querySelector</code>. It returns the first element that matches the given selector.</p>
<pre><code>&lt;div class=&quot;note&quot;&gt;First note
&lt;/div&gt;
&lt;div class=&quot;note&quot;&gt;Second note
&lt;/div&gt;
&lt;script&gt;
  let firstNote = document.querySelector(&#39;.note&#39;);
  alert(firstNote.innerHTML); // &quot;First note&quot;
&lt;/script&gt;
</code></pre>

</section>

      <section id="node-props">
        <h3>Node properties: type, tag, contents</h3>
    <p>
    Every element, text, or comment in a web page is a <strong>DOM node</strong>. 
    Each node belongs to a class in the DOM hierarchy that defines its properties and methods.
  </p>

  <h3>1. DOM Node Classes</h3>
  <p>
    The DOM is built on a class hierarchy:
  </p>
  <ul>
    <li><code>EventTarget</code> ‚Äì Base class that enables events.</li>
    <li><code>Node</code> ‚Äì Adds tree structure features (<code>parentNode</code>, <code>childNodes</code>).</li>
    <li><code>Element</code> ‚Äì Adds element-level features like <code>children</code> and <code>querySelector()</code>.</li>
    <li><code>HTMLElement</code> ‚Äì Base class for all HTML tags (<code>&lt;div&gt;</code>, <code>&lt;a&gt;</code>, etc.).</li>
    <li>Specific classes like <code>HTMLInputElement</code>, <code>HTMLBodyElement</code>, etc., add tag-specific features.</li>
  </ul>

  <p>
    Example:
  </p>
  <pre><code>let input = document.querySelector('input');
alert(input.constructor.name); // HTMLInputElement
</code></pre>

  <h3>2. Identifying Node Type</h3>
  <p>
    The <code>nodeType</code> property tells what kind of node you‚Äôre working with:
  </p>
  <ul>
    <li><code>1</code> ‚Üí Element</li>
    <li><code>3</code> ‚Üí Text</li>
    <li><code>9</code> ‚Üí Document</li>
  </ul>
  <pre><code>alert(document.body.nodeType); // 1
alert(document.body.firstChild.nodeType); // 3
</code></pre>

  <h3>3. Tag Name</h3>
  <p>
    You can get a node‚Äôs tag using <code>tagName</code> or <code>nodeName</code>:
  </p>
  <pre><code>alert(document.body.tagName); // BODY
alert(document.body.nodeName); // BODY
</code></pre>
  <p>
    <code>tagName</code> works only for elements, while <code>nodeName</code> also works for text or comment nodes.
  </p>

  <h3>4. innerHTML and outerHTML</h3>
  <p>
    <code>innerHTML</code> lets you read or replace the HTML inside an element.
  </p>
  <pre><code>document.body.innerHTML = "&lt;h1&gt;Welcome!&lt;/h1&gt;";</code></pre>
  <p>
    <code>outerHTML</code> includes the element itself. Writing to it replaces the element in the DOM.
  </p>
  <pre><code>div.outerHTML = "&lt;p&gt;Replaced!&lt;/p&gt;";</code></pre>

  <h3>5. textContent and nodeValue</h3>
  <p>
    Use <code>textContent</code> to safely get or set plain text (no HTML tags).  
    Use <code>nodeValue</code> or <code>data</code> to access the content of text or comment nodes.
  </p>
  <pre><code>elem.textContent = "&lt;b&gt;Safe text&lt;/b&gt;"; // shows literally, no bold
</code></pre>

  <h3>6. Hidden Property</h3>
  <p>
    The <code>hidden</code> attribute quickly hides elements, like <code>display:none</code> in CSS.
  </p>
  <pre><code>elem.hidden = true;</code></pre>

  <h3>7. Common Node Properties</h3>
  <ul>
    <li><code>value</code> ‚Üí for inputs</li>
    <li><code>href</code> ‚Üí for links</li>
    <li><code>id</code> ‚Üí for any element</li>
  </ul>

  <h3>Summary</h3>
  <ul>
    <li>Each DOM node belongs to a class and inherits properties from its hierarchy.</li>
    <li><code>nodeType</code>, <code>tagName</code>, and <code>nodeName</code> help identify nodes.</li>
    <li><code>innerHTML</code> and <code>outerHTML</code> handle HTML markup.</li>
    <li><code>textContent</code> and <code>data</code> handle plain text safely.</li>
    <li><code>hidden</code> quickly toggles visibility.</li>
  </ul>

  <div class="tip small">
    üí° <strong>Tip:</strong> Use <code>textContent</code> to safely insert text, 
    and <code>console.dir(element)</code> to inspect all its DOM properties.
  </div>
 
 
        <pre><code>const p = document.createElement('p');
p.nodeType;   // 1 = ELEMENT_NODE
p.tagName;    // "P"</code></pre>
      </section>

      <section id="attrs-props">
        <h3>Attributes &amp; properties</h3>
   <p>
    When the browser parses HTML, most <em>standard attributes</em> on elements become
    JavaScript <strong>DOM properties</strong>. But they aren‚Äôt always identical, and not every
    attribute becomes a property.
  </p>

  <h3>1) DOM Properties (JS side)</h3>
  <ul>
    <li>Live on the element object (regular JS object).</li>
    <li>Typed values (e.g., <code>checked</code> is boolean, <code>style</code> is an object).</li>
    <li>Case-sensitive names: use <code>elem.nodeType</code>, not <code>elem.NoDeTyPe</code>.</li>
    <li>You can add your own: <code>document.body.myData = {name:'Caesar'}</code>.</li>
  </ul>

  <pre><code>// Custom property
document.body.myData = { name: 'Caesar', title: 'Imperator' };
console.log(document.body.myData.title); // Imperator

// Prototype extension (affects all elements)
Element.prototype.sayHi = function () {
  console.log(`Hello, I'm &lt;${this.tagName.toLowerCase()}&gt;`);
};
document.body.sayHi(); // Hello, I'm &lt;body&gt;
</code></pre>

  <h3>2) HTML Attributes (markup side)</h3>
  <ul>
    <li>What you write in HTML.</li>
    <li>Names are <em>case-insensitive</em>; values are always <em>strings</em>.</li>
    <li>Some attributes are standard only for certain tags (e.g., <code>type</code> is standard on <code>&lt;input&gt;</code>, not on <code>&lt;body&gt;</code>).</li>
  </ul>

  <pre><code>&lt;div id="card" about="Elephant"&gt;&lt;/div&gt;
&lt;script&gt;
  const el = document.getElementById('card');
  console.log(el.getAttribute('About')); // "Elephant" (case-insensitive)
  el.setAttribute('data-note', 123);
  for (const a of el.attributes) {
    console.log(a.name, '=', a.value);
  }
&lt;/script&gt;
</code></pre>

  <h3>3) Working with Attributes (raw HTML values)</h3>
  <ul>
    <li><code>elem.hasAttribute(name)</code></li>
    <li><code>elem.getAttribute(name)</code></li>
    <li><code>elem.setAttribute(name, value)</code></li>
    <li><code>elem.removeAttribute(name)</code></li>
    <li><code>elem.attributes</code> ‚Üí iterable list of all attributes</li>
  </ul>

  <h3>4) Sync Rules (Attribute ‚áÑ Property)</h3>
  <p>
    Standard attributes usually sync with their properties, but not always both ways:
  </p>
  <ul>
    <li><strong>Two-way (usually):</strong> <code>id</code>
      <pre><code>input.setAttribute('id', 'x'); console.log(input.id); // "x"
input.id = 'y'; console.log(input.getAttribute('id')); // "y"</code></pre>
    </li>
    <li><strong>One-way:</strong> <code>value</code> (attribute ‚Üí property only)
      <pre><code>input.setAttribute('value', 'text'); console.log(input.value); // "text"
input.value = 'new'; console.log(input.getAttribute('value')); // "text" (unchanged original)</code></pre>
    </li>
    <li><strong>Typed differences:</strong> <code>checked</code> is boolean vs attribute is string/empty
      <pre><code>&lt;input type="checkbox" checked id="c"&gt;
c.getAttribute('checked'); // ""  (string)
c.checked;                 // true (boolean)</code></pre>
    </li>
    <li><strong>Normalized properties:</strong> <code>a.href</code> is always absolute
      <pre><code>&lt;a id="link" href="#hash"&gt;
link.getAttribute('href'); // "#hash"
link.href;                 // "https://example.com/page#hash"</code></pre>
    </li>
    <li><strong>Objects:</strong> <code>style</code> attribute is string; <code>elem.style</code> is CSS object
      <pre><code>div.getAttribute('style'); // "color:red;font-size:120%"
div.style.color;          // "red"</code></pre>
    </li>
  </ul>

  <h3>5) Custom Data: <code>data-*</code> & <code>dataset</code></h3>
  <p>
    Use <code>data-*</code> for safe, conflict-free custom attributes. Access them via <code>elem.dataset</code>
    (camelCase for multi-word).
  </p>
  <pre><code>&lt;div id="order" class="order" data-order-state="new"&gt;A new order&lt;/div&gt;
&lt;script&gt;
  console.log(order.dataset.orderState); // "new"
  order.dataset.orderState = 'pending';  // updates attribute and can drive CSS
&lt;/script&gt;

/* CSS */
.order[data-order-state="pending"] { color: blue; }
</code></pre>

  <h3>6) Quick Guidance</h3>
  <ul>
    <li>Prefer <strong>properties</strong> for day-to-day JS (typed, live state).</li>
    <li>Use <strong>attributes</strong> when you need the exact HTML value (<code>getAttribute</code>) or non-standard/custom data.</li>
    <li>For custom data, use <strong><code>data-*</code></strong> + <strong><code>dataset</code></strong>.</li>
    <li>Remember special sync cases (e.g., <code>value</code>).</li>
  </ul>

  <div class="tip small">
    üí° <strong>Rule of thumb:</strong> Read/write <em>current UI state</em> via properties.
    Read/write the <em>original markup</em> via attributes.
  </div>
 
      </section>

      <section id="modifying">
  <h2>Modifying the Document (DOM)</h2>
  <p>
    Create elements, insert them in precise positions, clone or remove nodes, and safely inject HTML or text.
  </p>

  <h3>1) Create Nodes</h3>
  <ul>
    <li><code>document.createElement(tag)</code> ‚Üí element node</li>
    <li><code>document.createTextNode(text)</code> ‚Üí text node</li>
  </ul>
  <pre><code>// Build: &lt;div class="alert"&gt;&lt;strong&gt;Hi!&lt;/strong&gt; You‚Äôve got a message.&lt;/div&gt;
const box = document.createElement('div');
box.className = 'alert';
box.innerHTML = '&lt;strong&gt;Hi!&lt;/strong&gt; You‚Äôve got a message.';
</code></pre>

  <h3>2) Insert Nodes (Modern)</h3>
  <ul>
    <li><code>parent.append(...nodes|strings)</code> ‚Äì end of parent</li>
    <li><code>parent.prepend(...)</code> ‚Äì start of parent</li>
    <li><code>node.before(...)</code> / <code>node.after(...)</code> ‚Äì around node</li>
    <li><code>node.replaceWith(...)</code> ‚Äì replace node</li>
  </ul>
  <pre><code>document.body.prepend(box);             // show at top
box.after(' (inline text)', document.createElement('hr'));</code></pre>
  <p class="note">Strings are inserted as <em>text</em> (escaped), not HTML.</p>

  <h3>3) Insert as HTML</h3>
  <p>Use <code>elem.insertAdjacentHTML(where, html)</code> for literal HTML.</p>
  <ul>
    <li><code>"beforebegin"</code> | <code>"afterbegin"</code> | <code>"beforeend"</code> | <code>"afterend"</code></li>
  </ul>
  <pre><code>box.insertAdjacentHTML('beforeend', '&lt;em&gt; Read this.&lt;/em&gt;');</code></pre>

  <h3>4) Remove / Move</h3>
  <ul>
    <li><code>node.remove()</code> ‚Äì delete node</li>
    <li>Re-inserting a node <em>moves</em> it automatically (no manual remove needed)</li>
  </ul>
  <pre><code>setTimeout(() => box.remove(), 1500);</code></pre>

  <h3>5) Clone</h3>
  <ul>
    <li><code>elem.cloneNode(true)</code> ‚Äì deep clone (with children)</li>
    <li><code>elem.cloneNode(false)</code> ‚Äì shallow clone</li>
  </ul>
  <pre><code>const copy = box.cloneNode(true);
copy.querySelector('strong').textContent = 'Bye!';
box.after(copy);</code></pre>

  <h3>6) Batching</h3>
  <p>
    Build lists off-DOM, then append once. Either:
    <code>DocumentFragment</code> or just collect nodes in an array and spread.
  </p>
  <pre><code>// Array approach (simple, fast)
const items = Array.from({length: 3}, (_, i) => {
  const li = document.createElement('li');
  li.textContent = i + 1;
  return li;
});
document.querySelector('#list').append(...items);</code></pre>

  <h3>7) Legacy Methods (know them, don‚Äôt start with them)</h3>
  <p><code>appendChild</code>, <code>insertBefore</code>, <code>replaceChild</code>, <code>removeChild</code> exist for older codebases.</p>

  <h3>8) ‚ö†Ô∏è Avoid <code>document.write</code></h3>
  <p>
    Only works during initial parsing; calling later wipes the page. Prefer the modern APIs above.
  </p>

  <div class="tip small">
    üí° <strong>Cheat sheet:</strong> Build with <code>createElement</code> ‚Üí insert with <code>append/prepend/before/after</code> ‚Üí
    HTML string? use <code>insertAdjacentHTML</code> ‚Üí batch many nodes ‚Üí clone with <code>cloneNode</code> ‚Üí remove with <code>remove()</code>.
  </div>

      </section>

      <section id="styles-classes">
   <h2>Styles & Classes</h2>
  <p>
    Prefer CSS classes for presentation. Use inline <code>style</code> from JS only when values are dynamic (e.g., computed positions).
  </p>

  <h3>1) Prefer Classes over Inline Styles</h3>
  <pre><code>/* CSS */
.btn { padding: .5rem 1rem; background: #0a7; color: #fff; }

/* JS: add the class instead of manual inline styling */
elem.classList.add('btn');</code></pre>

  <h3>2) className vs classList</h3>
  <ul>
    <li><code>elem.className</code> ‚Üí full class string (overwrites all).</li>
    <li><code>elem.classList</code> ‚Üí add/remove/toggle one class at a time.</li>
  </ul>
  <pre><code>// className (replace all)
elem.className = 'card card--primary';

// classList (surgical)
elem.classList.add('is-active');
elem.classList.remove('is-hidden');
elem.classList.toggle('dark');
elem.classList.contains('dark'); // true/false

// Iterate classes
for (const c of elem.classList) console.log(c);</code></pre>

  <h3>3) Inline Styles (when you must)</h3>
  <p>Use camelCase for multi-word properties. Remember units (<code>px</code>, <code>%</code>, etc.).</p>
  <pre><code>elem.style.backgroundColor = 'gold';
elem.style.zIndex = '10';
elem.style.left = leftPx + 'px';
elem.style.top  = topPx + 'px';</code></pre>

  <h4>Reset or Remove an Inline Style</h4>
  <pre><code>// reset one property
elem.style.display = '';                 // restores CSS/UA default
elem.style.removeProperty('background'); // remove explicitly-set inline style

// set many at once (replaces all inline styles!)
elem.style.cssText = `
  color: red !important;
  background-color: #ffe;
  padding: 8px;
`;</code></pre>

   

  <div class="tip small">
    üí° <strong>Cheat sheet:</strong> Style with CSS ‚Üí toggle via <code>classList</code> ‚Üí
    inline <code>style</code> only for dynamic numbers/positions ‚Üí reset with <code>''</code> or
    <code>removeProperty</code> ‚Üí read final values with <code>getComputedStyle</code>.
  </div>
</section>


      <section id="events">
   <h2>Introduction to Browser Events</h2>
  <p>
    An <strong>event</strong> signals that something happened (click, key press, form submit, etc.). 
    Handlers are functions that run in response.
  </p>

  <h3>Common Event Types</h3>
  <ul>
    <li><strong>Mouse:</strong> <code>click</code>, <code>contextmenu</code>, <code>mouseover</code>/<code>mouseout</code>, <code>mousedown</code>/<code>mouseup</code>, <code>mousemove</code></li>
    <li><strong>Keyboard:</strong> <code>keydown</code>, <code>keyup</code></li>
    <li><strong>Form:</strong> <code>submit</code>, <code>focus</code></li>
    <li><strong>Document:</strong> <code>DOMContentLoaded</code></li>
    <li><strong>CSS:</strong> <code>transitionend</code></li>
  </ul>

  <h3>Ways to Attach Handlers</h3>
  <ol>
    <li>
      <strong>HTML attribute</strong> (quick demos; avoid for real apps):
      <pre><code>&lt;input type="button" value="Click" onclick="sayHi()"&gt;</code></pre>
    </li>
    <li>
      <strong>DOM property</strong> (one handler per event):
      <pre><code>button.onclick = function () { alert('Thanks'); };
button.onclick = null; // remove</code></pre>
    </li>
    <li>
      <strong>addEventListener</strong> (multiple handlers + options):
      <pre><code>function handler(e){ console.log(e.type); }
button.addEventListener('click', handler, { once: true });
button.removeEventListener('click', handler);</code></pre>
      <small>Use for events like <code>DOMContentLoaded</code> (not available via <code>onDOMContentLoaded</code>).</small>
    </li>
  </ol>

  <h3>The Event Object</h3>
  <pre><code>button.addEventListener('click', function (event) {
  console.log(event.type);               // "click"
  console.log(event.currentTarget === this); // true (except in arrow functions)
  console.log(event.clientX, event.clientY); // mouse coords
});</code></pre>
  <p class="note">In HTML attributes, <code>event</code> is also available: <code>onclick="alert(event.type)"</code>.</p>

   

  <h3>Gotchas & Tips</h3>
  <ul>
    <li>Assign the function, don‚Äôt call it: <code>btn.onclick = sayHi</code> (‚úÖ), not <code>sayHi()</code> (‚ùå).</li>
    <li><code>removeEventListener</code> needs the <em>same</em> function reference used to add.</li>
    <li>Prefer <code>addEventListener</code> for composability and special events.</li>
    <li>Use options:
      <code>{ once: true }</code> auto-removes,
      <code>{ passive: true }</code> for scroll/touch (no <code>preventDefault()</code>),
      <code>{ capture: true }</code> to handle in capture phase.</li>
  </ul>

  <div class="tip small">
    üí° <strong>Cheat sheet:</strong> Use <code>addEventListener</code> ‚Üí keep a named handler for removal ‚Üí
    read details from <code>event</code> ‚Üí avoid inline HTML handlers in production.
  </div>
</section>

 

       

      <!-- PART 5 -->
      <section id="part5">
        <h2>PART 5 ¬∑ Network Requests</h2>
      </section>

      <section id="fetch">
        <h3>Fetch</h3>
        <pre><code>fetch('/api/items')
  .then(r =&gt; r.json())
  .then(items =&gt; alert(items))
  .catch(console.error);</code></pre>
      </section>

      <section id="formdata">
        <h3>FormData</h3>
        <pre><code>const fd = new FormData();
fd.append('file', new Blob(['hello'], {type:'text/plain'}), 'greet.txt');</code></pre>
      </section>

      <section id="fetch-api">
        <h3>Fetch API patterns</h3>
        <pre><code>const jsonPost = (url, body) =&gt; fetch(url, {
  method:'POST', headers:{'Content-Type':'application/json'},
  body: JSON.stringify(body)
}).then(r =&gt; {
  if(!r.ok) throw new Error(r.status);
  return r.json();
});</code></pre>
      </section>

      <section id="url">
        <h3>URL objects</h3>
        <pre><code>const u = new URL('https://example.com/products');
u.searchParams.set('q','adapter');
u.toString(); // "https://example.com/products?q=adapter"</code></pre>
      </section>

      <section id="xhr">
        <h3>XMLHttpRequest</h3>
        <p>Older API; still useful for progress events or legacy code.</p>
        <pre><code>const xhr = new XMLHttpRequest();
xhr.open('GET','/api/data');
xhr.onload = () =&gt; alert(xhr.responseText);
xhr.send();</code></pre>
      </section>

      <!-- PART 6 -->
      <section id="part6">
        <h2>PART 6 ¬∑ Storing Data in the Browser</h2>
      </section>

      <section id="cookies">
        <h3>Cookies &amp; <code>document.cookie</code></h3>
        <pre><code>document.cookie = "theme=dark; Path=/; Max-Age=31536000";</code></pre>
      </section>

      <section id="storage">
        <h3>localStorage &amp; sessionStorage</h3>
        <pre><code>localStorage.setItem('lang','en');
localStorage.getItem('lang'); // "en"
sessionStorage.clear();</code></pre>
      </section>

      <section id="indexeddb">
        <h3>IndexedDB</h3>
        <p>Asynchronous, transactional key‚Äìvalue database in the browser.</p>
        <pre><code>const req = indexedDB.open('mydb',1);
req.onupgradeneeded = (e) =&gt; e.target.result.createObjectStore('notes');
req.onsuccess = () =&gt; alert('DB ready');</code></pre>
      </section>

      <footer>

      </footer>
    </main>
  </div>

  <button class="top" title="Back to top" onclick="window.scrollTo({top:0,behavior:'smooth'})">‚Üë Top</button>

  <script>
    // Theme: init from localStorage or system preference
    (function () {
      const root = document.documentElement;
      const saved = localStorage.getItem('theme');
      const sys = window.matchMedia('(prefers-color-scheme: light)').matches ? 'light' : 'dark';
      const theme = saved || sys;
      root.setAttribute('data-theme', theme);
      window.__currentTheme = theme;
      window.addEventListener('DOMContentLoaded', () => {
        const btn = document.getElementById('theme-toggle');
        if (!btn) return;
        const setLabel = (t) => btn.textContent = t === 'light' ? 'üåô Dark' : '‚òÄÔ∏è Light';
        setLabel(theme);
        btn.addEventListener('click', () => {
          const next = (root.getAttribute('data-theme') === 'light') ? 'dark' : 'light';
          root.setAttribute('data-theme', next);
          localStorage.setItem('theme', next);
          setLabel(next);
        }, { passive: true });
      });
    })();
    /* Active link highlighting & quick filter */
    const headings = [...document.querySelectorAll('main section[id]')];
    const links = [...document.querySelectorAll('nav .toc a[href^="#"]')];
    const linkById = Object.fromEntries(links.map(a => [a.getAttribute('href').slice(1), a]));

    const observer = new IntersectionObserver(entries => {
      entries.forEach(e => {
        if (e.isIntersecting) {
          const id = e.target.id;
          links.forEach(a => a.classList.remove('active'));
          linkById[id]?.classList.add('active');
        }
      });
    }, { rootMargin: "-40% 0px -55% 0px", threshold: [0, 1] });

    headings.forEach(h => observer.observe(h));

    document.getElementById('toc-filter').addEventListener('input', e => {
      const q = e.target.value.toLowerCase().trim();
      links.forEach(a => {
        const show = a.textContent.toLowerCase().includes(q);
        a.parentElement.style.display = show ? '' : 'none';
      });
    });
  </script>

  <script>
    // in javascript add to every section in this page in the corner right bottom a page number
    const sections = document.querySelectorAll('main section');
    sections.forEach((s, i) => {
      const pagenum = document.createElement('span');
      pagenum.textContent = i + 1;
      pagenum.classList.add('pagenum');
      s.appendChild(pagenum);
    });


  </script>



  <script>
    (function () {
      // Utility: strip <script> tags if present
      function extractJS(raw) {
        return raw.replace(/<script[^>]*>/gi, '').replace(/<\/script>/gi, '').trim();
      }

      // Enhance all <pre><code> blocks
      document.querySelectorAll('pre > code').forEach((code) => {
        const pre = code.parentElement;

        // Save original for Reset
        code.dataset.original = code.textContent;

        // Toolbar
        const tools = document.createElement('div');
        tools.className = 'code-tools';
        const runBtn = document.createElement('button');
        runBtn.className = 'btn-run';
        runBtn.textContent = '‚ñ∂ Run';
        const resetBtn = document.createElement('button');
        resetBtn.className = 'btn-reset';
        resetBtn.textContent = 'Reset';

        tools.appendChild(runBtn);
        tools.appendChild(resetBtn);
        pre.appendChild(tools);


        function runCode(fromText) {
          try {
            const js = extractJS(fromText ?? code.textContent);
            new Function(js)();
          } catch (err) {
            alert('Error: ' + err.message);
          }
        }

        runBtn.addEventListener('click', () => runCode());

        resetBtn.addEventListener('click', () => {
          code.textContent = code.dataset.original || '';
        });

        // Make editable on double click
        code.addEventListener('dblclick', () => {
          if (code.isContentEditable) return;
          code.contentEditable = 'true';
          code.classList.add('editing');
          // Place caret at end
          const sel = window.getSelection();
          const range = document.createRange();
          range.selectNodeContents(code);
          range.collapse(false);
          sel.removeAllRanges();
          sel.addRange(range);
          code.focus();
        });

        // Exit edit mode on blur
        code.addEventListener('blur', () => {
          code.contentEditable = 'false';
          code.classList.remove('editing');
        });

        // Keyboard shortcuts while editing
        code.addEventListener('keydown', (e) => {
          if (!code.isContentEditable) return;

          // Esc = cancel changes (revert to last saved original? No‚Äîrevert to pre-edit state)
          if (e.key === 'Escape') {
            document.execCommand && document.execCommand('undo'); // best-effort revert last edit
            code.blur();
          }

          // Ctrl/Cmd + Enter = run
          if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
            e.preventDefault();
            code.blur();
            runCode(code.textContent);
          }

          // Keep Tab inserting spaces instead of focusing away
          if (e.key === 'Tab') {
            e.preventDefault();
            const spaces = '  ';
            // Insert at caret
            if (document.execCommand) document.execCommand('insertText', false, spaces);
          }
        });

        // Paste as plain text (avoid bringing HTML)
        code.addEventListener('paste', (e) => {
          if (!code.isContentEditable) return;
          e.preventDefault();
          const text = (e.clipboardData || window.clipboardData).getData('text');
          if (document.execCommand) document.execCommand('insertText', false, text);
        });
      });
    })();
  </script>

  <script>
    (function () {
      const nav = document.getElementById('side-nav');
      const btn = document.getElementById('mobile-menu');
      const backdrop = document.getElementById('backdrop');
      const links = nav.querySelectorAll('a[href^="#"]');

      function openNav() {
        nav.classList.add('open');
        backdrop.hidden = false;
        btn.setAttribute('aria-expanded', 'true');
        // trap focus to nav for accessibility
        nav.setAttribute('tabindex', '-1'); nav.focus();
        document.body.style.overflow = 'hidden';
      }
      function closeNav() {
        nav.classList.remove('open');
        backdrop.hidden = true;
        btn.setAttribute('aria-expanded', 'false');
        document.body.style.overflow = '';
      }

      btn.addEventListener('click', () => {
        if (nav.classList.contains('open')) closeNav(); else openNav();
      });
      backdrop.addEventListener('click', closeNav);
      document.addEventListener('keyup', (e) => { if (e.key === 'Escape') closeNav(); });
      links.forEach(a => a.addEventListener('click', closeNav)); // close after selecting a topic on mobile

      // Optional: close nav if window resized to desktop
      const mq = window.matchMedia('(min-width: 901px)');
      mq.addEventListener('change', (e) => { if (e.matches) closeNav(); });
    })();
  </script>
</body>


</html>